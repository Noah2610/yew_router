//! Route Component.
use super::YewRouterState;
use crate::component_router::render::Render;
use crate::component_router::router::Router;
use std::fmt::{Debug, Error as FmtError, Formatter};
use yew::{Children, Component, ComponentLink, Properties, ShouldRender};
use yew_router_path_matcher::{PathMatcher, Matches};

/// A nested component used inside of [Router](struct.Router.html) that can determine if a
/// sub-component can be rendered.
#[derive(Debug)]
pub struct Route<T: for<'de> YewRouterState<'de>> {
    props: RouteProps<T>,
}

/// An enum that contains variants that can match a route string
#[derive(Debug)]
pub enum Matcher {
    /// A matcher generated by the route macro.
    RouteMatcher(PathMatcher),
    /// A matcher that uses a regex to match and capture values.
    RegexMatcher,
    /// A user-defined matcher.
    CustomMatcher(Box<dyn MatcherProvider>)
}

/// Trait that allows user-defined matchers.
pub trait MatcherProvider: Debug {
    /// Given itself and a route string, determine if the route matches by returning an Option
    /// possibly containing any sections captured by the matcher.
    fn match_route_string<'a, 'b: 'a>(&'b self, route_string: &'a str) -> Option<Matches<'a>>;
}

impl Matcher {
    /// Given itself and a route string, determine if the route matches by returning an Option
    /// possibly containing any sections captured by the matcher.
    pub fn match_route_string<'a, 'b: 'a>(&'b self, route_string: &'a str) -> Option<Matches<'a>> {
        match self {
            Matcher::RouteMatcher(matcher) => {
                let (_rest, matches) = matcher.match_path(route_string).ok()?;
                Some(matches)
            }
            Matcher::RegexMatcher => unimplemented!("Regex support not implemented yet."),
            Matcher::CustomMatcher(matcher) => matcher.match_route_string(route_string)
        }
    }
}

impl From<PathMatcher> for Matcher {
    fn from(value: PathMatcher) -> Self {
        Matcher::RouteMatcher(value)
    }
}

impl From<Box<dyn MatcherProvider>> for Matcher {
    fn from(value: Box<dyn MatcherProvider>) -> Self {
        Matcher::CustomMatcher(value)
    }
}


/// Properties for Route.
///
/// The path matcher must be specified.
///
/// If only a `render` is specified, it will display its contents if it returns `Some` after the
/// path matcher succeeds in matching the URL.
/// If only the `children` are specified, they will be rendered if the path matcher matches the URL.
/// If both the `render` and `children` are specified, they will only both render
/// (`render` elements above the `children` elements in the DOM)
/// if the `render` returns `Some`.
#[derive(Properties)]
pub struct RouteProps<T: for<'de> YewRouterState<'de>> {
    /// Matches the url and can extract sections as matches to be used by the `Render`.
    #[props(required)]
    pub matcher: Matcher,
    /// Given matches matched from the URL, conditionally render the elements specified within.
    pub render: Render<T>,
    /// Will be rendered if it contains anything provided the `PathMatcher` matches the URL.
    pub children: Children<Router<T>>,
}

impl<T: for<'de> YewRouterState<'de>> Debug for RouteProps<T> {
    fn fmt(&self, f: &mut Formatter) -> Result<(), FmtError> {
        f.debug_struct("RouteProps")
            .field("matcher", &self.matcher)
            .field("render", &self.render)
            .field("children (length)", &self.children.len())
            .finish()
    }
}

impl<T: for<'de> YewRouterState<'de>> Component for Route<T> {
    type Message = ();
    type Properties = RouteProps<T>;

    fn create(props: Self::Properties, _link: ComponentLink<Self>) -> Self {
        Route { props }
    }

    fn update(&mut self, _msg: Self::Message) -> bool {
        false
    }

    fn change(&mut self, props: Self::Properties) -> ShouldRender {
        self.props = props;
        true
    }
}
